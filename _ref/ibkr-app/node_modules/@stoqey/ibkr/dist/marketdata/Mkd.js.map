{"version":3,"file":"Mkd.js","sourceRoot":"","sources":["../../src/marketdata/Mkd.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,8DAAyD;AACzD,wCAA4C;AAC5C,oCAAmC;AACnC,kDAAoD;AACpD,kDAAgD;AAChD,gDAAsD;AACtD,qDAA+B;AAE/B,IAAM,qBAAqB,GAAG,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,aAAa;AAE7I;IAAA;QAAA,iBAuOC;QAtOG,cAAS,GAAG,UAAU,CAAC,IAAI,CAAC;QAE5B,eAAU,GAAiC,EAAE,CAAC;QAC9C,aAAQ,GAAyB,EAAE,CAAC,CAAC,+BAA+B;QAyMpE,cAAS,GAAG,UAAC,MAAM,EAAE,IAAgB,EAAE,MAAoB;YACvD,IAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;YACtB,IAAM,WAAW,GAAG,KAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC1C,IAAI,WAAW,IAAI,GAAG,CAAC,OAAO,EAAE,GAAG,WAAW,CAAC,OAAO,EAAE,GAAG,qBAAqB,EAAE,CAAC;gBAC/E,KAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;gBAC5B,6DAA6D;gBAC7D,wCAAwC;gBACxC,wCAAwC;gBACxC,mCAAmC;gBACnC,IAAM,oBAAoB,GAAG,GAAG,CAAC,OAAO,EAAE,GAAG,qBAAqB,CAAC;gBACnE,IAAM,aAAa,GAAG,KAAI,CAAC,SAAS,CAAC,MAAM,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC;gBAC1E,IAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;gBAChD,IAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;gBAEhD,IAAM,cAAc,GAAG,IAAA,4BAAgB,EAAC,QAAQ,EAAE,IAAI,EAAE;oBACpD,IAAI,EAAE,KAAK;oBACX,MAAM,EAAE,KAAK;oBACb,KAAK,EAAE,MAAM;oBACb,IAAI,EAAE,OAAO;oBACb,IAAI,EAAE,KAAK;oBACX,GAAG,EAAE,KAAK;iBACb,CAAC,CAAC;gBACH,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,mCAAO,cAAc,SAAK,WAAW,OAAC,CAAC;YAClE,CAAC;QACL,CAAC,CAAA;IAEL,CAAC;IAjOG,iCAAY,GAAZ,UAAa,UAAiC;QAC1C,OAAO,IAAA,+BAAY,EAAC,UAAU,CAAC,CAAC;IACpC,CAAC;IAAA,CAAC;IAEF,6BAAQ,GAAR,UAAS,IAAgB;;QACrB,IAAM,MAAM,GAAG,IAAA,+BAAY,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAE7C,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC;YAC3B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;YAC7B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QACtC,CAAC;QAED,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QACvC,IAAM,EAAE,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC;QACzC,IAAM,GAAG,yBACF,IAAA,cAAI,EAAC,IAAI,EAAE,CAAC,YAAY,CAAC,CAAC,KAC7B,SAAS,EAAE,EAAE,EACb,IAAI,EAAE,IAAI,CAAC,IAAI,EACf,IAAI,EAAE,MAAA,IAAI,CAAC,IAAI,mCAAI,IAAI,CAAC,KAAK,EAC7B,IAAI,EAAE,MAAA,IAAI,CAAC,IAAI,mCAAI,IAAI,CAAC,KAAK,EAC7B,GAAG,EAAE,MAAA,IAAI,CAAC,GAAG,mCAAI,IAAI,CAAC,KAAK,EAC3B,KAAK,EAAE,IAAI,CAAC,KAAK,EACjB,MAAM,EAAE,MAAA,IAAI,CAAC,MAAM,mCAAI,CAAC,EACxB,IAAI,EAAE,MAAA,IAAI,CAAC,IAAI,mCAAI,IAAI,CAAC,KAAK,GAChC,CAAC;QAEF,0BAA0B;QAC1B,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,SAAS,IAAI,EAAE,EAAE,CAAC;YACnE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACjB,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;YACrC,OAAO;QACX,CAAC;QAED,wDAAwD;QACxD,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QACvC,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE,CAAC;YACb,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACrB,CAAC;aAAM,CAAC;YACJ,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;QAC/B,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;IACzC,CAAC;IAEM,8BAAS,GAAhB,UAAiB,MAAc,EAAE,eAAuB,EAAE,IAAY;QAAZ,qBAAA,EAAA,YAAY;QAClE,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QACrC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC;QAE1C,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAC5B,IAAI,MAAM,GAAG,CAAC,CAAC,CAAC;QAEhB,OAAO,IAAI,IAAI,KAAK,EAAE,CAAC;YACnB,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;YAE3C,IAAI,IAAI,EAAE,CAAC;gBACP,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,SAAS,IAAI,eAAe,EAAE,CAAC;oBACzC,MAAM,GAAG,GAAG,CAAC;oBACb,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC;gBACnB,CAAC;qBAAM,CAAC;oBACJ,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC;gBACpB,CAAC;YACL,CAAC;iBAAM,CAAC;gBACJ,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,SAAS,IAAI,eAAe,EAAE,CAAC;oBACzC,MAAM,GAAG,GAAG,CAAC;oBACb,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC;gBACpB,CAAC;qBAAM,CAAC;oBACJ,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC;gBACnB,CAAC;YACL,CAAC;QAEL,CAAC;QACD,2FAA2F;QAC3F,wEAAwE;QACxE,IAAI,MAAM,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;;;;;;;;;;;;;OAeG;IACU,mCAAc,GAA3B,UAA4B,QAA+B,EAAE,SAAe,EAAE,OAAa,EAAE,QAAiB;;;;gBACpG,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;gBACrC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBACrC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;oBAAE,sBAAO,EAAE,EAAC;gBAEpC,cAAc,GAAG,SAAS,CAAC,OAAO,EAAE,CAAC;gBACrC,YAAY,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;gBAEvC,sBAAsB;gBACtB,IAAI,KAAK,CAAC,cAAc,CAAC,IAAI,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC;oBAC/C,IAAA,SAAG,EAAC,UAAG,IAAI,CAAC,SAAS,oBAAiB,EAAE,oCAA6B,MAAM,CAAE,CAAC,CAAC;oBAC/E,sBAAO,EAAE,EAAC;gBACd,CAAC;gBAED,sBAAsB;gBACtB,IAAI,cAAc,GAAG,YAAY,EAAE,CAAC;oBAChC,IAAA,SAAG,EAAC,UAAG,IAAI,CAAC,SAAS,oBAAiB,EAAE,2CAAoC,MAAM,CAAE,CAAC,CAAC;oBACtF,sBAAO,EAAE,EAAC;gBACd,CAAC;gBAEG,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;gBAClD,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;gBAExD,kEAAkE;gBAClE,2BAA2B;gBAC3B,IAAI,QAAQ,KAAK,CAAC,CAAC,EAAE,CAAC;oBAClB,QAAQ,GAAG,CAAC,CAAC;gBACjB,CAAC;gBAED,6DAA6D;gBAC7D,gBAAgB;gBAChB,IAAI,MAAM,KAAK,CAAC,CAAC,EAAE,CAAC;oBAChB,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;gBAC7B,CAAC;gBAED,mBAAmB;gBACnB,IAAI,MAAM,GAAG,QAAQ,EAAE,CAAC;oBACpB,sBAAO,EAAE,EAAC;gBACd,CAAC;gBAEK,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;gBAE9C,KAAK,GAAG,UAAU,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;gBACpC,IAAI,GAAG,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,MAAM,IAAG,CAAC,CAAC,CAAC;gBAExD,IAAA,kBAAU,EAAC,UAAU,CAAC,CAAC;gBAEvB,IAAA,SAAG,EAAC,UAAG,IAAI,CAAC,SAAS,oBAAiB,EAAE,UAAG,UAAU,CAAC,MAAM,8BAAoB,MAAM,mBAAS,IAAA,0BAAa,EAAC,KAAK,CAAC,IAAI,CAAC,iBAAO,IAAA,0BAAa,EAAC,IAAI,CAAC,IAAI,CAAC,eAAK,IAAA,sBAAS,EAAC,KAAK,CAAC,KAAK,CAAC,kBAAQ,IAAA,sBAAS,EAAC,IAAI,CAAC,KAAK,CAAC,CAAE,CAAC,CAAC;gBAEnN,sBAAO,UAAU,EAAC;;;KACrB;IAAA,CAAC;IAEF;;;;;;;;;;;;;;;;OAgBG;IACU,6BAAQ,GAArB,UAAsB,QAA+B,EAAE,IAAW;;;;;gBACxD,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;gBACrC,SAAS,GAAG,MAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,OAAO,EAAE,mCAAI,IAAI,CAAC,GAAG,EAAE,CAAC;gBAEhD,uDAAuD;gBACvD,IAAI,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC;oBACnB,IAAA,SAAG,EAAC,UAAG,IAAI,CAAC,SAAS,cAAW,EAAE,oCAA6B,MAAM,CAAE,CAAC,CAAC;oBACzE,sBAAO,IAAI,EAAC;gBAChB,CAAC;gBAEK,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBACrC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;oBAAE,sBAAO,IAAI,EAAC;gBAEtC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;gBACxD,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,CAAC;oBACX,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;oBACpB,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;oBAEvC,6DAA6D;oBAC7D,IAAI,SAAS,IAAI,SAAS,GAAG,SAAS,CAAC,SAAS,EAAE,CAAC;wBAC/C,sBAAO,SAAS,EAAC;oBACrB,CAAC;oBAED,gEAAgE;oBAChE,IAAI,QAAQ,IAAI,SAAS,IAAI,QAAQ,CAAC,SAAS,EAAE,CAAC;wBAC9C,sBAAO,QAAQ,EAAC;oBACpB,CAAC;oBAED,mCAAmC;oBACnC,sBAAO,QAAQ,aAAR,QAAQ,cAAR,QAAQ,GAAI,IAAI,EAAC;gBAC5B,CAAC;gBACD,sBAAO,MAAA,IAAI,CAAC,OAAO,CAAC,mCAAI,IAAI,EAAC;;;KAChC;IA4BL,iBAAC;AAAD,CAAC,AAvOD,IAuOC;AAvOY,gCAAU","sourcesContent":["import { Instrument, MarketData } from \"../interfaces\";\nimport { Contract } from \"@stoqey/ib\";\nimport { getSymbolKey } from \"../utils/instrument.utils\";\nimport { plotMkdCli } from \"../utils/chart\";\nimport { log } from \"../utils/log\";\nimport { formatDateStr } from \"../utils/time.utils\";\nimport { formatDec } from \"../utils/data.utils\";\nimport { createAggregator } from \"../utils/mkd.utils\";\nimport omit from 'lodash/omit';\n\nconst MKD_CLEAN_UP_INTERVAL = process.env.MKD_CLEAN_UP_INTERVAL ? parseInt(process.env.MKD_CLEAN_UP_INTERVAL) : 1000 * 60 * 30; // 30 minutes\n\nexport class MkdManager {\n    logsNames = MkdManager.name;\n\n    marketData: Record<string, MarketData[]> = {};\n    _cleanUp: Record<string, Date> = {}; // symbol, last cleaned up date\n\n    getSymbolKey(instrument: Instrument | Contract): string {\n        return getSymbolKey(instrument);\n    };\n\n    cacheBar(data: MarketData): void {\n        const symbol = getSymbolKey(data.instrument);\n\n        if (!this.marketData[symbol]) {\n            this.marketData[symbol] = [];\n            this._cleanUp[symbol] = data.date;\n        }\n\n        const buffer = this.marketData[symbol];\n        const ts = new Date(data.date).getTime();\n        const bar: MarketData = {\n            ...omit(data, ['instrument']), // copy all other properties from other data sources, bid, reachedZero, maxSize, e.t.c....\n            timestamp: ts,\n            date: data.date,\n            open: data.open ?? data.close,\n            high: data.high ?? data.close,\n            low: data.low ?? data.close,\n            close: data.close,\n            volume: data.volume ?? 0,\n            vwap: data.vwap ?? data.close,\n        };\n\n        // Fast append if in order\n        if (buffer.length === 0 || buffer[buffer.length - 1].timestamp <= ts) {\n            buffer.push(bar);\n            this.doCleanUp(symbol, data, buffer);\n            return;\n        }\n\n        // Otherwise insert at correct index using binary search\n        const idx = this.findIndex(symbol, ts);\n        if (idx === -1) {\n            buffer.push(bar);\n        } else {\n            buffer.splice(idx, 0, bar);\n        }\n        this.doCleanUp(symbol, data, buffer);\n    }\n\n    public findIndex(symbol: string, targetTimestamp: number, last = false): number {\n        const data = this.marketData[symbol];\n        if (!data || data.length === 0) return -1;\n\n        let left = 0;\n        let right = data.length - 1;\n        let result = -1;\n\n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n\n            if (last) {\n                if (data[mid].timestamp <= targetTimestamp) {\n                    result = mid;\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            } else {\n                if (data[mid].timestamp >= targetTimestamp) {\n                    result = mid;\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n\n        }\n        // If no result found and we're looking for insertion point, return the length of the array\n        // This means the target timestamp is older than all existing timestamps\n        if (result === -1 && !last) {\n            return data.length;\n        }\n\n        return result;\n    }\n\n    /**\n     * Get historical data for a given time range using binary search\n     * \n     * @param contract - The instrument to query\n     * @param startDate - Start of the range\n     * @param endDate - End of the range\n     * @param interval - Optional interval for aggregation (not yet implemented)\n     * @returns Array of market data within the range\n     * \n     * @example\n     * const data = await manager.historicalData(\n     *   instrument,\n     *   new Date('2024-01-15T10:30:00Z'),\n     *   new Date('2024-01-15T10:35:00Z')\n     * );\n     */\n    public async historicalData(contract: Instrument | Contract, startDate: Date, endDate: Date, interval?: string): Promise<MarketData[]> {\n        const symbol = this.getSymbolKey(contract);\n        const data = this.marketData[symbol];\n        if (!data || data.length === 0) return [];\n\n        const startTimestamp = startDate.getTime();\n        const endTimestamp = endDate.getTime();\n\n        // Validate timestamps\n        if (isNaN(startTimestamp) || isNaN(endTimestamp)) {\n            log(`${this.logsNames}.historicalData`, `Invalid date provided for ${symbol}`);\n            return [];\n        }\n\n        // Validate date range\n        if (startTimestamp > endTimestamp) {\n            log(`${this.logsNames}.historicalData`, `Start date is after end date for ${symbol}`);\n            return [];\n        }\n\n        let startIdx = this.findIndex(symbol, startTimestamp);\n        let endIdx = this.findIndex(symbol, endTimestamp, true);\n\n        // If startIdx is -1, it means startDate is before all data points\n        // Use first item (index 0)\n        if (startIdx === -1) {\n            startIdx = 0;\n        }\n\n        // If endIdx is -1, it means endDate is after all data points\n        // Use last item\n        if (endIdx === -1) {\n            endIdx = data.length - 1;\n        }\n\n        // Final validation\n        if (endIdx < startIdx) {\n            return [];\n        }\n\n        const slicedData = data.slice(startIdx, endIdx + 1);\n\n        const first = slicedData && slicedData[0];\n        const last = (slicedData || [])[slicedData?.length - 1];\n\n        plotMkdCli(slicedData);\n\n        log(`${this.logsNames}.historicalData`, `${slicedData.length} data points for ${symbol} from ${formatDateStr(first.date)} to ${formatDateStr(last.date)} @${formatDec(first.close)} -> @${formatDec(last.close)}`);\n\n        return slicedData;\n    };\n\n    /**\n     * Get quote at or before specified timestamp (point-in-time lookup)\n     * Returns the most recent data point at or before the requested time.\n     * If no data exists before the requested time, returns the first available data point.\n     * \n     * @param contract - The instrument to query\n     * @param date - The timestamp to query (defaults to current time)\n     * @returns The market data at or before the specified time, or null if no data exists\n     * \n     * @example\n     * // Get current quote\n     * const quote = await manager.getQuote(instrument);\n     * \n     * @example\n     * // Get historical quote at specific time\n     * const quote = await manager.getQuote(instrument, new Date('2024-01-15T10:32:00Z'));\n     */\n    public async getQuote(contract: Instrument | Contract, date?: Date): Promise<MarketData> {\n        const symbol = this.getSymbolKey(contract);\n        const timestamp = date?.getTime() ?? Date.now();\n        \n        // Validate timestamp (check for NaN from invalid Date)\n        if (isNaN(timestamp)) {\n            log(`${this.logsNames}.getQuote`, `Invalid date provided for ${symbol}`);\n            return null;\n        }\n        \n        const data = this.marketData[symbol];\n        if (!data || data.length === 0) return null;\n\n        const closest = this.findIndex(symbol, timestamp, true);\n        if (closest === -1) {\n            const firstItem = data[0];\n            const lastItem = data[data.length - 1];\n            \n            // If query timestamp is before first item, return first item\n            if (firstItem && timestamp < firstItem.timestamp) {\n                return firstItem;\n            }\n            \n            // If query timestamp is at or after last item, return last item\n            if (lastItem && timestamp >= lastItem.timestamp) {\n                return lastItem;\n            }\n            \n            // Fallback (should not reach here)\n            return lastItem ?? null;\n        }\n        return data[closest] ?? null;\n    }\n\n    doCleanUp = (symbol, data: MarketData, buffer: MarketData[]) => {\n        const now = data.date;\n        const lastCleanUp = this._cleanUp[symbol];\n        if (lastCleanUp && now.getTime() - lastCleanUp.getTime() > MKD_CLEAN_UP_INTERVAL) {\n            this._cleanUp[symbol] = now;\n            // MarketData = [dateOld, ..., dateNew] (chronological order)\n            // slice items before CLEAN_UP_INTERVAL,\n            // aggregate the sliced items by minute,\n            // add them back to the marketData \n            const lastCleanUpTimestamp = now.getTime() - MKD_CLEAN_UP_INTERVAL;\n            const oldItemsIndex = this.findIndex(symbol, lastCleanUpTimestamp, false);\n            const oldItems = buffer.slice(0, oldItemsIndex);\n            const lastNewItem = buffer.slice(oldItemsIndex);\n\n            const aggregatedData = createAggregator(oldItems, \"1m\", {\n                vwap: 'sum',\n                volume: 'sum',\n                close: 'last',\n                open: 'first',\n                high: 'max',\n                low: 'min'\n            });\n            this.marketData[symbol] = [...aggregatedData, ...lastNewItem];\n        }\n    }\n\n}\n"]}